<!DOCTYPE html>
<html>
<head>
<title>Snowfall</title>
</head>
<body style="margin: 0; padding: 0; background: black;">
<canvas id="canvas" width="1270" height="710"></canvas>
<canvas id="background" width="1270" height="710" style="display: none"></canvas>
<img id="imageBackground" src="./snowfall_background.png" style="display: none" />
<script type="text/javascript">
/* Initial setup of global variables */
var ctx = document.getElementById("canvas").getContext("2d");
var background = document.getElementById("background").getContext("2d");
var paused = false;
var lastTimestamp = null;

var width = ctx.canvas.width;
var height = ctx.canvas.height;

var counter = 1;
var snowflakes = [];
var ongoingTouches = [];

var foreImg;
var backImg;
var backImgData;
var foreImgData;

var dragX = 0;
var touch = 0;
var mouseDown = false;

window.onload = function(){
	/* Draw into the background image */
	var img = document.getElementById("imageBackground");
	background.drawImage(img, 0, 0);

	/* Add event handlers on the canvas */
	var canvas = document.getElementById("canvas");
	canvas.addEventListener("touchstart", handleTouchStart, false);
	canvas.addEventListener("touchend", handleTouchEnd, false);
	canvas.addEventListener("touchcancel", handleTouchCancel, false);
	canvas.addEventListener("touchmove", handleTouchMove, false);
	canvas.addEventListener("mousedown", handleMouseDown, false);
	canvas.addEventListener("mousemove", handleMouseMove, false);
	canvas.addEventListener("mouseup", handleMouseUp, false);

	/* Make two copies of the background pixels - one to draw the
     * foreground onto, and one to make updates to the background */
    foreImg = background.getImageData(0, 0, width, height);
    backImg = background.getImageData(0, 0, width, height);
	
	foreImgData = foreImg.data;
	backImgData = backImg.data;

	/* Set the animation to run every 50 milliseconds (20 times per second) */
	/*setInterval(animationTick, 50);*/
	window.requestAnimationFrame(animationTick);
}; /* End of window load event handler */


/* The main animation loop */
function animationTick(timestamp){
	if (paused) {
		window.requestAnimationFrame(animationTick);
		return;
	}
	
	if (!lastTimestamp)
		lastTimestamp = timestamp;
	
	/* If less than 50ms have passed since the last time we animated, don't do any work this time around */
	if (timestamp - lastTimestamp < 50) {
		window.requestAnimationFrame(animationTick);
		return;
	} else {
		/* Otherwise, if we are going to do work, update the last timestamp we ran at */
		lastTimestamp = timestamp;
	}
		
    /* Make two copies of the background pixels - one to draw the
     * foreground onto, and one to make updates to the background */
    foreImg = background.getImageData(0, 0, width, height);
    backImg = background.getImageData(0, 0, width, height);

	foreImgData = foreImg.data;
	backImgData = backImg.data;

	touch *= 0.995;
	
	/* Copy the background to the foreground every frame */
	/*for (var i = 0; i < backImg.data.length; i++) {
		foreImgData[i] = backImgData[i];
	}*/
    
    counter++;
    if (counter >= 2) {
        counter = 0;
        
        /* Create a new snowflake to add to the list */
        var snowflake = {
            x: (Math.random() * width),
            y: 0,
			/* velocity */
            xVel: (Math.random() * 4 - 2),
            yVel: 1,
			size: (Math.round(Math.random() * 2))
        };

        snowflakes.push(snowflake);
    }
    
	/* Set up some wind in a cycle */
	var wind = new Date().getSeconds();
	wind %= 10;
	if (5 < wind){
		wind = 11 - wind;
	}
	wind -= 2.5;
	
	/* Decrease the wind velocity a bit */
	wind *= 0.5;

    var i = 0;
    /* Loop through all the snowflakes to process each one. 
	 * Use a while loop instead of a for loop. That is because if an item
     * needs to be removed from the list, we shuffle the last item into
     * that empty slot, and need to re-process that slot again */
    while(i < snowflakes.length) {
        snowflake = snowflakes[i];
                
        /* Check if the snowflake is off the edge of the page */
        if (snowflake.y > height /*|| Math.random() < 0.0001*/) {
            removeArrayItem(i, snowflakes);
            continue;
        }
		
		/* Update the snowflake velocity */
        /* First, move the xvelocity towards 0 if it has changed */
        /*if (snowflake.xVel > 0.1) {
             -= 0.1;
        } else if (snowflake.xVel < -0.1) {
            snowflake.xVel += 0.1;
        } else {
			snowflake.xVel = 0;
        }*/
		
		/* If the snowflake is dropping slowly because it hit something, gradually increase
		 * velocity towards 1 */
		if (snowflake.yVel < 0.9) {
			snowflake.yVel += 0.1;
		} else {
			/* Apply a slight amount of random variation to the vertical velocity */
			snowflake.yVel = 0.9 + snowflake.size * Math.random();
		}

		/* Apply the wind */
		var targetXVel = Math.random() * wind + touch;
		if (snowflake.xVel < targetXVel - 0.2)
			snowflake.xVel += 0.2;
		else if (snowflake.xVel > targetXVel + 0.2)
			snowflake.xVel -= 0.2;
		else
			snowflake.xVel = targetXVel;

        
        /* Check if the snowflake is about to hit something */
        if (isObstacle(Math.round(snowflake.x + snowflake.xVel), 
                       Math.round(snowflake.y + snowflake.yVel), 
                       backImgData)) {
            
			/* Check if we can continue moving by changing direction within reasonable limits */
			var min = -1;
			if (snowflake.xVel < -1)
				min = Math.round(snowflake.xVel);
			var max = 1;
			if (snowflake.xVel > 1)
				max = Math.round(snowflake.xVel);
			var isStuck = true;
			
			/* Loop through the possible new directions we could go and check for obstacles */
			for (var dir = min; dir <= max; dir++) {
				if (!isObstacle(Math.round(snowflake.x + dir),
								Math.round(snowflake.y + snowflake.yVel),
								backImgData)) {
					/* Change to the new direction */
					snowflake.xVel = dir;
					isStuck = false;
					/*snowflake.yVel = 0.5;*/
				}
			}
            
			if (isStuck) {
                /* We are stuck. Permanently draw the snowflake 
                 * into the background image (and into the foreground 
                 * image for this time) */
                drawSnowflake(Math.round(snowflake.x),
                              Math.round(snowflake.y),
                              backImg.data, snowflake.size);
                drawSnowflake(Math.round(snowflake.x),
                              Math.round(snowflake.y),
                              foreImgData, snowflake.size);

                /* Remove the snowflake from circulation */
                removeArrayItem(i, snowflakes);
                continue;
            }
        }

			
        /* Then, do the actual movement */
        snowflake.x += snowflake.xVel;
        snowflake.y += snowflake.yVel;

        /* Make sure we aren't past the end of the array now if an 
        item was removed */
        if (i < snowflakes.length) {
			drawSnowflake(Math.round(snowflake.x), 
                          Math.round(snowflake.y), 
                          foreImgData, snowflake.size);
        }
            
        i++;
    }

	/* Write the foreground image to the main drawing canvas context */    
    ctx.putImageData(foreImg, 0, 0);
	background.putImageData(backImg, 0, 0);
	
	/* Set up the next frame */
	window.requestAnimationFrame(animationTick);
}

/* Draw a pixel in the image array */
function drawPixel(x, y, R, G, B, A, data) {
	if (x >= 0 && x < width && y >= 0 && y < height) {
        /* Find index in pixel array */
        var p = 4 * y * width + 4 * x;

        /* Set RGBA to white */
        data[p] = R;
        data[p + 1] = G;
        data[p + 2] = B;
        data[p + 3] = A;  
    }
}

function drawSnowflake(x, y, data, s){
	switch(s){
	case 1:
		drawPixel(x-1, y, 210, 210, 210, 210, data);
		drawPixel(x+1, y, 210, 210, 210, 210, data);
		drawPixel(x, y-1, 210, 210, 210, 210, data);
		drawPixel(x, y+1, 210, 210, 210, 210, data);
	case 0:
		drawPixel(x, y, 255, 255, 255, 255, data);
	}
}

/* Check if a pixel is an obstacle */
function isObstacle(x, y, data) {
    if (x >= 0 && x < width && y >= 0 && y < height) {
    	var p = 4 * y * width + 4 * x;
    
    	if (data[p] > 0 || data[p + 1] > 0 || data[p + 2] > 0) {
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
}

/* Remove an item from the array, and replace it with the last item in the
 * array so it shrinks */
function removeArrayItem(currentIndex, list) {
    /* Pop the last item out of the array */
    last = list.pop();           

    /* Check if this item was last in the array (if currentIndex equals
     * the new, shorter length */
    if (currentIndex == list.length)
        return null;

    /* Not sure if this is necessary to clean up memory usage? */
    /*list[currentIndex] = null;*/

    /* Move the last item here */
    list[currentIndex] = last;
    
    return last;
}

/* Handle touch events. Currently, they do NOT work with multi-touch! */
function handleTouchStart(evt){
	/* Pause the animation so the computer has more CPU cycles to deal with the touch event */
	paused = true;
	
	evt.preventDefault();
	var touches = evt.changedTouches;
	for (var i = 0; i < touches.length; i++) {
		ongoingTouches.push(copyTouch(touches[i]));
	}	
}

function handleTouchMove(evt){
	evt.preventDefault();
	/*
	Wait till event is done to do anything
	
	var touches = evt.changedTouches;
	for (var i = 0; i < touches.length; i++) {
		var idx = ongoingTouchIndexById(touches[i].identifier);

		if (idx >= 0) {
			ongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
		}
	}*/
}

function handleTouchEnd(evt){
	evt.preventDefault();
	var touches = evt.changedTouches;
	for (var i = 0; i < touches.length; i++) {
		var idx = ongoingTouchIndexById(touches[i].identifier);
		
		/* Record a touch "swipe" - the horizontal distance to affect the wind */
		touch = (touches[i].pageX - ongoingTouches[idx].pageX) / 10;
		if (touch > 10)
			touch = 10;
		else if (touch < -10)
			touch = -10;
			
		if (idx >= 0) {
			ongoingTouches.splice(idx, 1);  // remove it; we're done
		}
	}
	
	/* Un-pause the animation if all touches are done */
	if (ongoingTouches.length == 0)
		paused = false;
}

function handleTouchCancel(evt){
	evt.preventDefault();
	var touches = evt.changedTouches;
	for (var i = 0; i < touches.length; i++) {
		ongoingTouches.splice(idx, 1);  // remove it; we're done
	}
	
	/* Un-pause the animation if all touches are done */
	if (ongoingTouches.length == 0)
		paused = false;	
}

/* Touch helper functions */
function ongoingTouchIndexById(idToFind) {
	for (var i = 0; i < ongoingTouches.length; i++) {
		var id = ongoingTouches[i].identifier;

		if (id == idToFind) {
			return i;
		}
	}
	return -1;    // not found
}

function copyTouch(touch) {
  return { identifier: touch.identifier, pageX: touch.pageX, pageY: touch.pageY };
}


/* Handle mouse events */
function handleMouseDown(evt) {
	dragX = evt.clientX;
	mouseDown = true;
}

function handleMouseMove(evt) {
	if (mouseDown) 
		touch = (evt.clientX - dragX) / 10;
}

function handleMouseUp(evt) {
	touch = (evt.clientX - dragX) / 10;
	if (touch > 10)
		touch = 10;
	else if (touch < -10)
		touch = -10;
		
	mouseDown = false;
}
</script>
</body>
</html>